// The base specs for this are Bluetooth® Secure Simple Pairing Using NFC, with some bits coming
// from ISO 7816-4 and ISO 18013-5.

use anyhow::{anyhow, bail, Context, Result};
use ndef_rs::{NdefRecord, TNF};
use serde::{Deserialize, Serialize};
use tracing::info;
use uuid::Uuid;

use crate::{
    cbor,
    definitions::{
        device_engagement::nfc::{
            ble::ad_packet::KnownType,
            ndef_handover::{LeRole, RecordType},
        },
        helpers::ByteStr,
        DeviceEngagement,
    },
};

#[derive(Debug, Clone)]
pub enum ReaderHandoverState {
    WaitingForAidResponse,
    WaitingForCapabilitiesFileResponse,
    WaitingForCapabilitiesReadResponse,
    WaitingForNdefFileResponse,
    WaitingForNdefReadResponseLength,
    WaitingForNdefReadResponseData { total_length: usize, data: Vec<u8> },
    Done,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReaderNegotiatedCarrierInfo {
    pub device_engagement: DeviceEngagement,
    pub uuid: Uuid,
    pub holder_le_role: LeRole,
    /// Handover Select Message
    pub hs_message: ByteStr,
    /// Handover Request Message
    pub hr_message: Option<ByteStr>,
    pub ble_device_address: Option<ByteStr>,
}

impl ReaderNegotiatedCarrierInfo {
    pub fn parse_ndef_message(ndef_response: &[u8]) -> Result<Self, anyhow::Error> {
        let hs_message = ByteStr::from(ndef_response.to_vec());
        let ndef_message =
            ndef_rs::NdefMessage::decode(ndef_response).context("Failed to decode ndef message")?;
        let ndef_records = ndef_message.records();

        match ndef_records.iter().find(|r| {
            r.record_type() == RecordType::TnepServiceParameter.as_bytes()
                && r.tnf() == TNF::WellKnown
        }) {
            None => Self::parse_ndef_message_static(hs_message, ndef_records)
                .context("Failed to parse static handover NDEF message"),
            Some(_) => bail!("negotiated handover not supported"),
        }
    }

    fn parse_ndef_message_static(
        hs_message: ByteStr,
        ndef_records: &[NdefRecord],
    ) -> Result<Self, anyhow::Error> {
        if ndef_records.len() < 3 {
            bail!("Not enough NDEF records");
        }
        // let hs_record = &ndef_records[0];
        let device_engagement_record = &ndef_records[1];
        let cc_record = &ndef_records[2];

        let device_engagement: DeviceEngagement = {
            if device_engagement_record.record_type() != b"iso.org:18013:deviceengagement" {
                bail!("device engagement record does not have correcty type");
            }
            cbor::from_slice(device_engagement_record.payload())
                .context("Could not parse device engagement CBOR bytes")?
        };

        let (holder_le_role, uuid, ble_device_address) =
            parse_cc_record(cc_record).context("failed to parse cc record")?;

        Ok(Self {
            device_engagement,
            holder_le_role: holder_le_role.context("Could not find LE role in NDEF record")?,
            uuid: uuid.context("Could not find UUID in NDEF record")?,
            hs_message,
            hr_message: None,
            ble_device_address,
        })
    }
}

fn parse_cc_record(
    cc_record: &NdefRecord,
) -> Result<(Option<LeRole>, Option<Uuid>, Option<ByteStr>)> {
    let mut holder_le_role = None;
    let mut uuid = None;
    let mut ble_device_address = None;

    if cc_record.record_type() != b"application/vnd.bluetooth.le.oob" {
        bail!("cc record does not have correct type");
    }
    let mut remains = cc_record.payload();

    // Order of AD (Advertising and Scan Response Data) fields isn't mandated, so we have to take
    // out what we are interested in as we go.
    while !remains.is_empty() {
        let (info, remains_) = remains
            .split_first_chunk::<2>()
            .context("remainin cc record data did not have 2 bytes for the metadata")?;
        remains = remains_;
        // length includes the datatype byte
        let ad_len = info[0];
        let ad_datatype = info[1];
        let (ad_data, remains_) = remains
            .split_at_checked((ad_len - 1).into())
            .context("Remaining cc record data was not big enough for the length advertized")?;
        remains = remains_;
        match KnownType::try_from(ad_datatype) {
            Ok(KnownType::LeRole) => {
                if ad_len != 2 {
                    bail!("LE Role length expected to be 2, but got {ad_len}");
                }
                holder_le_role =
                    Some(LeRole::from_repr(ad_data[0]).context("Failed to parse LE role")?);
            }
            Ok(KnownType::CompleteList128BitServiceUuids) => match ad_len {
                17 => {
                    let mut uuid_bytes = ad_data.to_vec();
                    uuid_bytes.reverse();
                    uuid =
                        Some(Uuid::from_bytes(uuid_bytes.try_into().map_err(|_| {
                            anyhow!("UUID does not match advertised length")
                        })?));
                }
                l => bail!("Unsupported UUID length: {l}"),
            },
            Ok(KnownType::MacAddress) => match ad_len {
                // mac address is encoded in little endian
                7 => {
                    ble_device_address =
                        Some(ad_data.iter().copied().rev().collect::<Vec<u8>>().into());
                }
                8 => {
                    // Bluetooth® Secure Simple Pairing Using NFC specs have examples with 7 bytes
                    // long mac address (even though they say it should be 6 bytes long) and the
                    // last byte is seemingly discarded from the descriptions
                    ble_device_address = Some(
                        ad_data[..7]
                            .iter()
                            .copied()
                            .rev()
                            .collect::<Vec<u8>>()
                            .into(),
                    );
                }
                l => bail!("Unsupported MAC address length: {l}"),
            },
            _ => {
                info!("Unknown AD datatype: {:#2X?}", ad_datatype)
            }
        }
    }
    Ok((holder_le_role, uuid, ble_device_address))
}

#[cfg(test)]
mod test {
    use crate::definitions::device_engagement::nfc::{
        ndef_handover::get_static_handover_ndef_response, StaticHandoverState,
    };

    use super::*;

    #[test]
    fn roundtrip() {
        let state = StaticHandoverState::new().expect("failed to generate handover state");
        let handover_response =
            get_static_handover_ndef_response(state).expect("failed to get ndef message");
        ReaderNegotiatedCarrierInfo::parse_ndef_message(&handover_response.ndef)
            .expect("failed to parse ndef message");
    }

    fn test_sample_cc_record(sample: Vec<u8>) {
        let ndef_message =
            ndef_rs::NdefMessage::decode(sample).expect("Failed to decode ndef message");
        let ndef_records = ndef_message.records();
        let cc_record = ndef_records
            .iter()
            .find(|r| r.record_type() == b"application/vnd.bluetooth.le.oob")
            .expect("couldn't find cc record");
        let (holder_le_role, _, ble_device_address) =
            parse_cc_record(cc_record).expect("failed to parse cc record");
        assert!(holder_le_role.is_some());
        assert!(ble_device_address.is_some());
        // those samples don't have Service Class UUID Bluetooth EIR Data Types
    }

    #[test]
    #[ignore = "doesn't have a BLE OOB record"]
    /// From Bluetooth® Secure Simple Pairing Using NFC
    /// Table 6: Binary Content of a Sample Bluetooth Handover Request Message
    fn sample_ble_handover_request_message_table_6() {
        let sample = vec![
            0x91, 0x02, 0x11, 0x48, 0x72, 0x13, 0x91, 0x02, 0x02, 0x63, 0x72, 0x01, 0x02, 0x51,
            0x02, 0x04, 0x61, 0x63, 0x01, 0x01, 0x30, 0x00, 0x5A, 0x20, 0x43, 0x01, 0x61, 0x70,
            0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x76, 0x6E, 0x64, 0x2E,
            0x62, 0x6C, 0x75, 0x65, 0x74, 0x6F, 0x6F, 0x74, 0x68, 0x2E, 0x65, 0x70, 0x2E, 0x6F,
            0x6F, 0x62, 0x30, 0x43, 0x00, 0x01, 0x07, 0x80, 0x80, 0xBF, 0xA1, 0x04, 0x0D, 0x20,
            0x06, 0x08, 0x11, 0x0E, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06,
            0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x11, 0x0F, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A,
            0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x05, 0x03, 0x06, 0x11,
            0x20, 0x11, 0x0B, 0x09, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65,
        ];
        test_sample_cc_record(sample);
    }

    #[test]
    #[ignore = "doesn't have a BLE OOB record"]
    /// From Bluetooth® Secure Simple Pairing Using NFC
    /// Table 7: Binary Content of a Sample Bluetooth Handover Select Message
    fn sample_ble_handover_request_message_table_7() {
        let sample = vec![
            0x91, 0x02, 0x0A, 0x48, 0x73, 0x13, 0xD1, 0x02, 0x04, 0x61, 0x63, 0x01, 0x01, 0x30,
            0x00, 0x5A, 0x20, 0x43, 0x01, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69,
            0x6F, 0x6E, 0x2F, 0x76, 0x6E, 0x64, 0x2E, 0x62, 0x6C, 0x75, 0x65, 0x74, 0x6F, 0x6F,
            0x74, 0x68, 0x2E, 0x65, 0x70, 0x2E, 0x6F, 0x6F, 0x62, 0x30, 0x43, 0x00, 0x03, 0x07,
            0x80, 0x88, 0xbf, 0x01, 0x04, 0x0D, 0x80, 0x06, 0x04, 0x11, 0x0E, 0x0F, 0x0E, 0x0D,
            0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x11,
            0x0F, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03,
            0x02, 0x01, 0x00, 0x05, 0x03, 0x18, 0x11, 0x23, 0x11, 0x0B, 0x09, 0x44, 0x65, 0x76,
            0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65,
        ];
        test_sample_cc_record(sample);
    }

    #[test]
    /// From Bluetooth® Secure Simple Pairing Using NFC
    /// Table 8: Binary Content of a Bluetooth LE Handover Request Message
    fn sample_ble_handover_request_message_table_8() {
        let sample = vec![
            0x91, 0x02, 0x11, 0x48, 0x72, 0x13, 0x91, 0x02, 0x02, 0x63, 0x72, 0x01, 0x02, 0x51,
            0x02, 0x04, 0x61, 0x63, 0x01, 0x01, 0x30, 0x00, 0x5A, 0x20, 0x55, 0x01, 0x61, 0x70,
            0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x76, 0x6E, 0x64, 0x2E,
            0x62, 0x6C, 0x75, 0x65, 0x74, 0x6F, 0x6F, 0x74, 0x68, 0x2E, 0x6c, 0x65, 0x2E, 0x6F,
            0x6F, 0x62, 0x30, 0x08, 0x1B, 0x01, 0x07, 0x80, 0x80, 0xBF, 0xA1, 0x00, 0x02, 0x1C,
            0x03, 0x11, 0x10, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
            0x11, 0x00, 0x00, 0x00, 0x11, 0x11, 0x22, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
            0x11, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x11, 0x23, 0x00, 0x00, 0x00,
            0x12, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x12, 0x03,
            0x19, 0x80, 0x00, 0x0B, 0x09, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d,
            0x65, 0x02, 0x01, 0x06,
        ];
        test_sample_cc_record(sample);
    }

    #[test]
    /// From Bluetooth® Secure Simple Pairing Using NFC
    /// Table 9: Binary Content of a Bluetooth LE Handover Select Message
    fn sample_ble_handover_request_message_table_9() {
        let sample = vec![
            0x91, 0x02, 0x0A, 0x48, 0x73, 0x13, 0xD1, 0x02, 0x04, 0x61, 0x63, 0x01, 0x01, 0x30,
            0x00, 0x5A, 0x20, 0x52, 0x01, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69,
            0x6F, 0x6E, 0x2F, 0x76, 0x6E, 0x64, 0x2E, 0x62, 0x6C, 0x75, 0x65, 0x74, 0x6F, 0x6F,
            0x74, 0x68, 0x2E, 0x6c, 0x65, 0x2E, 0x6F, 0x6F, 0x62, 0x30, 0x08, 0x1B, 0xC8, 0xDC,
            0xF4, 0x55, 0x2A, 0x77, 0x01, 0x02, 0x1C, 0x00, 0x11, 0x10, 0x00, 0x00, 0x00, 0x11,
            0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x11, 0x22,
            0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00,
            0x00, 0x11, 0x11, 0x23, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00,
            0x00, 0x12, 0x00, 0x00, 0x00, 0x12, 0x03, 0x19, 0xC1, 0x03, 0x0B, 0x09, 0x44, 0x65,
            0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65,
        ];
        test_sample_cc_record(sample);
    }

    #[test]
    #[ignore = "doesn't have a BLE OOB record"]
    /// From Bluetooth® Secure Simple Pairing Using NFC
    /// Table 10: Binary Content of a Sample Bluetooth Handover Select Message on an NFC
    fn sample_ble_handover_request_message_table_10() {
        let sample = vec![
            0x91, 0x02, 0x0A, 0x48, 0x73, 0x13, 0xD1, 0x02, 0x04, 0x61, 0x63, 0x03, 0x01, 0x30,
            0x00, 0x5A, 0x20, 0x1F, 0x01, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69,
            0x6F, 0x6E, 0x2F, 0x76, 0x6E, 0x64, 0x2E, 0x62, 0x6C, 0x75, 0x65, 0x74, 0x6F, 0x6F,
            0x74, 0x68, 0x2E, 0x65, 0x70, 0x2E, 0x6F, 0x6F, 0x62, 0x30, 0x1F, 0x00, 0x03, 0x07,
            0x80, 0x88, 0xbf, 0x01, 0x04, 0x0D, 0x80, 0x06, 0x04, 0x05, 0x03, 0x18, 0x11, 0x23,
            0x11, 0x0B, 0x09, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65,
        ];
        test_sample_cc_record(sample);
    }

    #[test]
    /// From Bluetooth® Secure Simple Pairing Using NFC
    /// Table 11: Binary Content of a Bluetooth LE Handover Select Message on an NFC Forum
    fn sample_ble_handover_request_message_table_11() {
        let sample = vec![
            0x91, 0x02, 0x0A, 0x48, 0x73, 0x13, 0xD1, 0x02, 0x04, 0x61, 0x63, 0x01, 0x01, 0x30,
            0x00, 0x5A, 0x20, 0x52, 0x01, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69,
            0x6F, 0x6E, 0x2F, 0x76, 0x6E, 0x64, 0x2E, 0x62, 0x6C, 0x75, 0x65, 0x74, 0x6F, 0x6F,
            0x74, 0x68, 0x2E, 0x6c, 0x65, 0x2E, 0x6F, 0x6F, 0x62, 0x30, 0x08, 0x1B, 0x18, 0x3B,
            0x4B, 0x1C, 0x3B, 0xCA, 0x01, 0x02, 0x1C, 0x00, 0x11, 0x10, 0x00, 0x00, 0x00, 0x11,
            0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x11, 0x22,
            0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00,
            0x00, 0x11, 0x11, 0x23, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00,
            0x00, 0x12, 0x00, 0x00, 0x00, 0x12, 0x03, 0x19, 0xC1, 0x03, 0x0B, 0x09, 0x44, 0x65,
            0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65,
        ];
        test_sample_cc_record(sample);
    }
}
